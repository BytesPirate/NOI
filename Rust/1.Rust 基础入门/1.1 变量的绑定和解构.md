# 变量命名

在命名方面，需要遵守[Rust命名规范](https://course.rs/practice/naming.html)

# 变量绑定

在Rust中，我们使用`let`来对某一个数值进行赋值

```rust
let a = "hello,world";
```

同时给这个过程起了一个名字，叫做**变量绑定**

# 变量可变性

Rust的变量在默认情况下是**不可变**的，可以通过使用`mut`关键字来让变量变为可变。

对于一个变量`a`来说，一旦未它绑定了某一个值，就不能在修改`a`

```rust
fn main() {
	let a = 5;
	println!("{}", a);
	a = 6;
	println!("{}", a);
}
```

运行上面的代码，会得到一条报错：

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let a = 5;
  |         -
  |         |
  |         first assignment to `a`
  |         help: consider making this binding mutable: `mut a`
3 |     println!("{}", x);
4 |     a = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

```

具体的错误原因是 `cannot assign twice to immutable variable a`（无法对不可变的变量进行重复赋值），因为我们想为不可变的 `a` 变量再次赋值。

选择可变还是不可变，更多的取决于你的使用场景，不可变带来了安全性，但是丧失了灵活性和性能（如果需要改变，就需要创建一个新的变量），而可变变量最大的好处就是使用上灵活性和性能上的提升。例如：在使用大型数据结构和或者热点代码更新路径（被大量频繁调用）的情况下，在同一内存位置更新实例可能比复制并返回新分配的实例来的更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。

# 使用下划线忽略未使用的变量

如果创建了一个变量却不在任何地方使用它，Rust通常会给你一个警告，因为可能会是一个BUG，但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型活刚开始一个项目的时候，这时你希望告诉**Rust不要警告未使用的变量，为此可以使用下划线作为变量名的开头**。

```rust
fn main() {
	let _x = 5;
	let y = 10;
}
```

```bash
warning: unused variable: `y`
 --> src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default

```

# 变量解构

`let`表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
	let (a, mut b): (bool, bool) = (true, false);
	// a = true, 不可变； b = false, 可变
	println!("a = {:?}, b = {:?}", a, b);

	b = true;
	assert_eq!(a, b);
}
```

## 解构式赋值

